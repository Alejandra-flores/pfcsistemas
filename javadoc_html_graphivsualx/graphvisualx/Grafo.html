<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="es">
<head>
<!-- Generated by javadoc (version 1.7.0_147-icedtea) on Tue Feb 14 17:18:34 CET 2012 -->
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
<title>Grafo</title>
<meta name="date" content="2012-02-14">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Grafo";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../graphvisualx/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../graphvisualx/Grafico.html" title="class in graphvisualx"><span class="strong">Prev Class</span></a></li>
<li><a href="../graphvisualx/Graphvisualx.html" title="class in graphvisualx"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?graphvisualx/Grafo.html" target="_top">Frames</a></li>
<li><a href="Grafo.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">graphvisualx</div>
<h2 title="Class Grafo" class="title">Class Grafo</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>graphvisualx.Grafo</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">Grafo</span>
extends java.lang.Object</pre>
<div class="block">Fichero Grafo.java</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../graphvisualx/Grafo.html#Grafo()">Grafo</a></strong>()</code>
<div class="block">Constructor nulo.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../graphvisualx/Grafo.html#Grafo(int, boolean)">Grafo</a></strong>(int&nbsp;n,
     boolean&nbsp;dir)</code>
<div class="block">Constructor predeterminado.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../graphvisualx/Grafo.html#Grafo(int, boolean, boolean)">Grafo</a></strong>(int&nbsp;n,
     boolean&nbsp;ady,
     boolean&nbsp;dir)</code>
<div class="block">Constructor predeterminado.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../graphvisualx/Grafo.html#Grafo(java.lang.String)">Grafo</a></strong>(java.lang.String&nbsp;fileName)</code>
<div class="block">Constructor predeterminado.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#Aciclico()">Aciclico</a></strong>()</code>
<div class="block">Algoritmo de comprobación de ciclos - Método modificador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="../graphvisualx/Arista.html" title="class in graphvisualx">Arista</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#Bellman_Ford(int)">Bellman_Ford</a></strong>(int&nbsp;origen)</code>
<div class="block">Algoritmo de Bellman-Ford - Método modificador
 Calcula los caminos de coste mínimo entre origen y todos los vértices 
 del grafo G (en este caso origen es 0 y los costes pueden ser negativos).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#colores()">colores</a></strong>()</code>
<div class="block">Algoritmo de obtención del número cromático - Método modificador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Collection</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#devolver_grafo()">devolver_grafo</a></strong>()</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int[][]</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#devolver_matriz()">devolver_matriz</a></strong>()</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#Dijkstra()">Dijkstra</a></strong>()</code>
<div class="block">Algoritmo de Dijkstra - Método modificador
 Calcula los caminos de coste mínimo entre origen y todos los vértices 
 del grafo G (en este caso origen es 0).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int[][]</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#Dijkstra(int)">Dijkstra</a></strong>(int&nbsp;origen)</code>
<div class="block">Algoritmo de Dijkstra - Método modificador
 Calcula los caminos de coste mínimo entre origen y todos los vértices 
 del grafo G.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#es_adyacencia()">es_adyacencia</a></strong>()</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#es_circular()">es_circular</a></strong>()</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#es_completo()">es_completo</a></strong>()</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#es_conexo()">es_conexo</a></strong>()</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#es_dirigido()">es_dirigido</a></strong>()</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#es_lineal()">es_lineal</a></strong>()</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#es_vacio()">es_vacio</a></strong>()</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;java.lang.Integer&gt;</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#euler()">euler</a></strong>()</code>
<div class="block">Algoritmo de comprobación de camino euleriano - Método modificador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int[][]</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#Floyd()">Floyd</a></strong>()</code>
<div class="block">Algoritmo de Floyd - Método modificador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#grado_nodo()">grado_nodo</a></strong>()</code>
<div class="block">Método modificador (sobrecargado).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#grado_nodo(int)">grado_nodo</a></strong>(int&nbsp;vertice)</code>
<div class="block">Método modificador (sobrecargado).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#grado_nodo(int, int[][])">grado_nodo</a></strong>(int&nbsp;vertice,
          int[][]&nbsp;G)</code>
<div class="block">Método modificador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.ArrayList&lt;java.lang.Integer&gt;</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#hallar_corte()">hallar_corte</a></strong>()</code>
<div class="block">Algoritmo de comprobación de vértices de corte - Método modificador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="../graphvisualx/Arista.html" title="class in graphvisualx">Arista</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#hallar_puente()">hallar_puente</a></strong>()</code>
<div class="block">Algoritmo de comprobación de aristas de corte - Método modificador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#Hamilton()">Hamilton</a></strong>()</code>
<div class="block">Algoritmo de comprobación hamiltoniana - Método modificador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="../graphvisualx/Arista.html" title="class in graphvisualx">Arista</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#Kruskal()">Kruskal</a></strong>()</code>
<div class="block">Algoritmo de Kruskal - Método modificador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#mostrar_grafo()">mostrar_grafo</a></strong>()</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#mostrar_matriz()">mostrar_matriz</a></strong>()</code>
<div class="block">Método observador
 Muestra por la salida estándar el contenido del grafo, esta vez bajo una
 representación de una matriz.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#n_aristas()">n_aristas</a></strong>()</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#n_nodos()">n_nodos</a></strong>()</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#nueva_arista(int, int)">nueva_arista</a></strong>(int&nbsp;vertice_i,
            int&nbsp;vertice_j)</code>
<div class="block">Método modificador (matriz de adyacencia).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#nueva_arista(int, int, int)">nueva_arista</a></strong>(int&nbsp;vertice_i,
            int&nbsp;vertice_j,
            int&nbsp;peso)</code>
<div class="block">Método modificador (matriz de costes - sobrecargado).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#nueva_componente(graphvisualx.Grafo)">nueva_componente</a></strong>(<a href="../graphvisualx/Grafo.html" title="class in graphvisualx">Grafo</a>&nbsp;g)</code>
<div class="block">Método modificador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#nuevo_nodo(int)">nuevo_nodo</a></strong>(int&nbsp;componente)</code>
<div class="block">Método modificador (sobrecargado).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#nuevo_nodo(int, int)">nuevo_nodo</a></strong>(int&nbsp;peso,
          int&nbsp;componente)</code>
<div class="block">Método modificador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;java.lang.Integer&gt;</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#orden_topologico()">orden_topologico</a></strong>()</code>
<div class="block">Algoritmo de ordenación topológica - Método modificador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#peso_arista(int, int)">peso_arista</a></strong>(int&nbsp;vertice_i,
           int&nbsp;vertice_j)</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#peso_vertice(int)">peso_vertice</a></strong>(int&nbsp;vertice)</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="../graphvisualx/Arista.html" title="class in graphvisualx">Arista</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#Prim()">Prim</a></strong>()</code>
<div class="block">Algoritmo de Prim - Método modificador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;java.lang.Integer&gt;</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#Rec_Anchura()">Rec_Anchura</a></strong>()</code>
<div class="block">Algoritmo de Recorrido en Anchura (BFS) - Método modificador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.ArrayList&lt;java.lang.Integer&gt;</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#Rec_Profundidad()">Rec_Profundidad</a></strong>()</code>
<div class="block">Algoritmo de Recorrido en Profundidad (DFS) - Método modificador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#vertice_corte()">vertice_corte</a></strong>()</code>
<div class="block">Algoritmo de comprobación de vértices de corte - Método modificador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int[][]</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Grafo.html#Warshall()">Warshall</a></strong>()</code>
<div class="block">Algoritmo de Warshall - Método modificador.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Grafo()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Grafo</h4>
<pre>public&nbsp;Grafo()</pre>
<div class="block">Constructor nulo.</div>
</li>
</ul>
<a name="Grafo(int, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Grafo</h4>
<pre>public&nbsp;Grafo(int&nbsp;n,
     boolean&nbsp;dir)
      throws java.lang.Exception</pre>
<div class="block">Constructor predeterminado.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>n</code> - es el número de nodos total para el grafo.</dd><dd><code>dir</code> - valor booleano que especifica si el grafo será dirigido o no.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="Grafo(int, boolean, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Grafo</h4>
<pre>public&nbsp;Grafo(int&nbsp;n,
     boolean&nbsp;ady,
     boolean&nbsp;dir)
      throws java.lang.Exception</pre>
<div class="block">Constructor predeterminado.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>n</code> - es el número de nodos total para el grafo.</dd><dd><code>ady</code> - es un valor booleano que indica si es o no un grafo de aristas
 adyacentes y no de aristas con costes asociados.</dd><dd><code>dir</code> - valor booleano que especifica si el grafo será dirigido o no.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="Grafo(java.lang.String)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Grafo</h4>
<pre>public&nbsp;Grafo(java.lang.String&nbsp;fileName)
      throws java.lang.Exception</pre>
<div class="block">Constructor predeterminado.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fileName</code> - cadena de caracteres que representa el nombre del
 fichero en donde se encuentra definido la matriz del grafo y su
 número de nodos, si es de adyacencia o no; y si se dirigido o no.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="n_aristas()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>n_aristas</h4>
<pre>public&nbsp;int&nbsp;n_aristas()
              throws java.lang.Exception</pre>
<div class="block">Método observador.
 Devuelve el número de aristas que componen el grafo.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>número de aristas del grafo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="n_nodos()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>n_nodos</h4>
<pre>public&nbsp;int&nbsp;n_nodos()
            throws java.lang.Exception</pre>
<div class="block">Método observador.
 Devuelve el número de nodos o vértices que componen el grafo.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>número de vértices del grafo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="peso_arista(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>peso_arista</h4>
<pre>public&nbsp;int&nbsp;peso_arista(int&nbsp;vertice_i,
              int&nbsp;vertice_j)
                throws java.lang.Exception</pre>
<div class="block">Método observador.
 Devuelve el valor del peso de la arista que une ambos vértices.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>vertice_i</code> - valor entero que corresponde al vértice i de la arista.</dd><dd><code>vertice_j</code> - valor entero que corresponde al vértice j de la arista.</dd>
<dt><span class="strong">Returns:</span></dt><dd>devuelve el valor del peso de la arista.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="peso_vertice(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>peso_vertice</h4>
<pre>public&nbsp;int&nbsp;peso_vertice(int&nbsp;vertice)
                 throws java.lang.Exception</pre>
<div class="block">Método observador.
 Devuelve el valor del peso del vértice (si es que tiene).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>vertice</code> - valor entero que se corresponde con un nodo del grafo (debe de existir).</dd>
<dt><span class="strong">Returns:</span></dt><dd>devuelve el peso correspondiente para el vértice (si es que tiene).</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="nuevo_nodo(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nuevo_nodo</h4>
<pre>public&nbsp;void&nbsp;nuevo_nodo(int&nbsp;peso,
              int&nbsp;componente)
                throws java.lang.Exception</pre>
<div class="block">Método modificador.
 Inserta un nuevo nodo en el grafo.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>peso</code> - valor entero que corresponde con el peso del nodo.</dd><dd><code>componente</code> - valor entero que corresponde con la componente del grafo (por defecto la primera componente será 0).</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="nuevo_nodo(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nuevo_nodo</h4>
<pre>public&nbsp;void&nbsp;nuevo_nodo(int&nbsp;componente)
                throws java.lang.Exception</pre>
<div class="block">Método modificador (sobrecargado).
 Inserta un nuevo nodo en el grafo (si no queremos insertar un peso
 para el nodo en concreto).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>componente</code> - valor entero que corresponde con la componente del grafo (por defecto la primera componente será 0).</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="nueva_arista(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nueva_arista</h4>
<pre>public&nbsp;void&nbsp;nueva_arista(int&nbsp;vertice_i,
                int&nbsp;vertice_j)
                  throws java.lang.Exception</pre>
<div class="block">Método modificador (matriz de adyacencia).
 Inserta una nueva arista en el grafo.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>vertice_i</code> - valor entero que corresponde al vértice i del grafo.</dd><dd><code>vertice_j</code> - valor entero que corresponde vértice j del grafo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="nueva_arista(int, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nueva_arista</h4>
<pre>public&nbsp;void&nbsp;nueva_arista(int&nbsp;vertice_i,
                int&nbsp;vertice_j,
                int&nbsp;peso)
                  throws java.lang.Exception</pre>
<div class="block">Método modificador (matriz de costes - sobrecargado).
 Inserta una nueva arista en el grafo.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>vertice_i</code> - valor entero que corresponde con el vértice i del grafo.</dd><dd><code>vertice_j</code> - valor entero que corresponde con el vértice j del grafo.</dd><dd><code>peso</code> - valor entero que corresponde con el peso del nodo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="nueva_componente(graphvisualx.Grafo)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nueva_componente</h4>
<pre>public&nbsp;void&nbsp;nueva_componente(<a href="../graphvisualx/Grafo.html" title="class in graphvisualx">Grafo</a>&nbsp;g)
                      throws java.lang.Exception</pre>
<div class="block">Método modificador.
 Inserta una nueva componente en el grafo.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>g</code> - Componente conexa final (grafo) que se añadirá a la componente
 conexa actual (grafo de trabajo).</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="es_adyacencia()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>es_adyacencia</h4>
<pre>public&nbsp;boolean&nbsp;es_adyacencia()
                      throws java.lang.Exception</pre>
<div class="block">Método observador.
 Dice si el grafo trabaja con valores de adyacencia para sus nodos
 o no.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>boolean devuelve true o false dependiendo de si el grafo es de adyacencia o no.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="es_dirigido()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>es_dirigido</h4>
<pre>public&nbsp;boolean&nbsp;es_dirigido()
                    throws java.lang.Exception</pre>
<div class="block">Método observador.
 Dice si el grafo tiene la aristas en forma dirigida
 o no.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>boolean devuelve true o false dependiendo de si el grafo es dirigido o no.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="es_conexo()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>es_conexo</h4>
<pre>public&nbsp;boolean&nbsp;es_conexo()
                  throws java.lang.Exception</pre>
<div class="block">Método observador.
 Comprueba si el grafo (o componente) es conexa o no.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>boolean devolverá true o false si el grafo es o no conexo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="es_circular()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>es_circular</h4>
<pre>public&nbsp;boolean&nbsp;es_circular()
                    throws java.lang.Exception</pre>
<div class="block">Método observador.
 Comprueba si el grafo (o componente) es circular o no.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>boolean devolverá true o false si el grafo es o no circular.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="es_vacio()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>es_vacio</h4>
<pre>public&nbsp;boolean&nbsp;es_vacio()
                 throws java.lang.Exception</pre>
<div class="block">Método observador.
 Comprueba si el grafo (o componente) es vacío o no.
 Esta función comprueba que hay vértice pero no tiene aristas.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>boolean devolverá true o false si el grafo es o no vacío.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="es_completo()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>es_completo</h4>
<pre>public&nbsp;boolean&nbsp;es_completo()
                    throws java.lang.Exception</pre>
<div class="block">Método observador.
 Comprueba si el grafo (o componente) es completo o no.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>boolean devolverá true o false si el grafo es o no completo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="es_lineal()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>es_lineal</h4>
<pre>public&nbsp;boolean&nbsp;es_lineal()
                  throws java.lang.Exception</pre>
<div class="block">Método observador.
 Comprueba si el grafo (o componente) es lineal o no.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>boolean devolverá true o false si el grafo es o no lineal.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="devolver_grafo()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>devolver_grafo</h4>
<pre>public&nbsp;java.util.Collection&nbsp;devolver_grafo()
                                    throws java.lang.Exception</pre>
<div class="block">Método observador.
 Devuelve la representación interna del grafo(Conjunto de ArrayList).</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>Collection Es un conjunto de claves-valor (ArrayList) que representa
 la estructura interna del grafo según se ha definido.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="devolver_matriz()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>devolver_matriz</h4>
<pre>public&nbsp;int[][]&nbsp;devolver_matriz()
                        throws java.lang.Exception</pre>
<div class="block">Método observador.
 Devuelve una matriz con la estructura de los elementos del grafo.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>int[][] matriz (Array multidimensional) con la estructura de los 
 elementos del grafo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="mostrar_grafo()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mostrar_grafo</h4>
<pre>public&nbsp;void&nbsp;mostrar_grafo()
                   throws java.lang.Exception</pre>
<div class="block">Método observador.
 Muestra por la salida estándar el contenido del grafo.</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="mostrar_matriz()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mostrar_matriz</h4>
<pre>public&nbsp;void&nbsp;mostrar_matriz()
                    throws java.lang.Exception</pre>
<div class="block">Método observador
 Muestra por la salida estándar el contenido del grafo, esta vez bajo una
 representación de una matriz.</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="Dijkstra()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Dijkstra</h4>
<pre>public&nbsp;void&nbsp;Dijkstra()
              throws java.lang.Exception</pre>
<div class="block">Algoritmo de Dijkstra - Método modificador
 Calcula los caminos de coste mínimo entre origen y todos los vértices 
 del grafo G (en este caso origen es 0).</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="Dijkstra(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Dijkstra</h4>
<pre>public&nbsp;int[][]&nbsp;Dijkstra(int&nbsp;origen)
                 throws java.lang.Exception</pre>
<div class="block">Algoritmo de Dijkstra - Método modificador
 Calcula los caminos de coste mínimo entre origen y todos los vértices 
 del grafo G.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>origen</code> - valor entero que representa el nodo origen para el
 algoritmo.</dd>
<dt><span class="strong">Returns:</span></dt><dd>devuelve la matriz resultante del procesamiento de Dijkstra.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="Floyd()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Floyd</h4>
<pre>public&nbsp;int[][]&nbsp;Floyd()
              throws java.lang.Exception</pre>
<div class="block">Algoritmo de Floyd - Método modificador.
 Calcula los caminos de coste mínimo entre cada par de vértice de todo
 el grafo.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>devuelve una matriz de enteros que representará el resultado
 del procesamiento del grafo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="Warshall()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Warshall</h4>
<pre>public&nbsp;int[][]&nbsp;Warshall()
                 throws java.lang.Exception</pre>
<div class="block">Algoritmo de Warshall - Método modificador.
 Determina si hay un camino entre cada par de vértices del grafo G.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>devuelve una matriz de enteros que será el resultado
 del procesamiento del algoritmo sobre el grafo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="Prim()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Prim</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="../graphvisualx/Arista.html" title="class in graphvisualx">Arista</a>&gt;&nbsp;Prim()
                                 throws java.lang.Exception</pre>
<div class="block">Algoritmo de Prim - Método modificador.
 Devuelve el conjunto de aristas que forman un árbol
 generador de coste mínimo del grafo conexo.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>una estructura de tipo ArrayList cuyo contenido son del tipo
 Arista. En esta estructura se encuentra un conjunto de aristas que forman
 un árbol generador de coste mínimo del grafo conexo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="Kruskal()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Kruskal</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="../graphvisualx/Arista.html" title="class in graphvisualx">Arista</a>&gt;&nbsp;Kruskal()
                                    throws java.lang.Exception</pre>
<div class="block">Algoritmo de Kruskal - Método modificador.
 Muestra por la salida estándar el conjunto de aristas que forman un árbol
 generador de coste mínimo del grafo conexo.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>devuelve un ArrayList de tipo Arista que contiene el árbol
 de expansión mínimo del grafo según el procesamiento del algoritmo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="Rec_Profundidad()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Rec_Profundidad</h4>
<pre>public&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;Rec_Profundidad()
                                                       throws java.lang.Exception</pre>
<div class="block">Algoritmo de Recorrido en Profundidad (DFS) - Método modificador.
 Muestra por la salida estándar el conjunto de nodos que forman el camino
 tras realizar una búsqueda en profundidad de sus elementos.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>devuelve un ArrayList de tipo entero que contiene el recorrido
 en profundidad del grafo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="Rec_Anchura()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Rec_Anchura</h4>
<pre>public&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;Rec_Anchura()
                                                   throws java.lang.Exception</pre>
<div class="block">Algoritmo de Recorrido en Anchura (BFS) - Método modificador.
 Muestra por la salida estándar el conjunto de nodos que forman el camino
 tras realizar una búsqueda en anchura de sus elementos.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>devuelve un ArrayList de tipo entero que contiene el recorrido
 en anchura del grafo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="Aciclico()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Aciclico</h4>
<pre>public&nbsp;boolean&nbsp;Aciclico()
                 throws java.lang.Exception</pre>
<div class="block">Algoritmo de comprobación de ciclos - Método modificador.
 Muestra por la salida estándar si el grafo contiene ciclos o no
 (Se realiza comprobación para grafos dirigidos y no dirigidos).</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>Devuelve un tipo boolean que se corresponderá con los valores
 true (aciclico) o false (no aciclico).</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="Hamilton()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Hamilton</h4>
<pre>public&nbsp;void&nbsp;Hamilton()
              throws java.lang.Exception</pre>
<div class="block">Algoritmo de comprobación hamiltoniana - Método modificador.
 Muestra por la salida estándar el conjunto de nodos que conforman
 el camino hamiltoniano, siempre y cuando el grafo sea hamiltoniano.</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="colores()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>colores</h4>
<pre>public&nbsp;int&nbsp;colores()
            throws java.lang.Exception</pre>
<div class="block">Algoritmo de obtención del número cromático - Método modificador.
 Muestra por la salida estándar el número cromático posible para la
 coloración de vértices del grafo de trabajo.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>un valor de tipo entero que representará uno de los posibles
 números cromáticos del grafo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="euler()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>euler</h4>
<pre>public&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;euler()
                                             throws java.lang.Exception</pre>
<div class="block">Algoritmo de comprobación de camino euleriano - Método modificador.
 Devuelve el conjunto de nodos que forman un camino
 euleriano, siempre y cuando el grafo sea euleriano (Distinción entre
 grafos dirigidos y no dirigidos).</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>Devuelve una estructura de tipo ArrayList cuyo contenido es
 de tipo Integer. En la estructura se encuentra el conjunto de nodos
 que forman un camino euleriano, siempre y cuando el grafo sea euleriano.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="grado_nodo(int, int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grado_nodo</h4>
<pre>public&nbsp;int&nbsp;grado_nodo(int&nbsp;vertice,
             int[][]&nbsp;G)
               throws java.lang.Exception</pre>
<div class="block">Método modificador.
 Devuelve para el vértice del grafo, el valor de valencia o grado 
 en tipo entero.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>vertice</code> - valor entero que se corresponde con el nodo del grafo.</dd><dd><code>G</code> - matriz bidimensional de enteros que representa el grafo de
 trabajo.</dd>
<dt><span class="strong">Returns:</span></dt><dd>int valor entero que representa el grado del nodo vértice.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="grado_nodo(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grado_nodo</h4>
<pre>public&nbsp;int&nbsp;grado_nodo(int&nbsp;vertice)
               throws java.lang.Exception</pre>
<div class="block">Método modificador (sobrecargado).
 Muestra por la salida estándar para el vértice del grafo, el 
 valor de valencia o grado en tipo entero.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>vertice</code> - valor entero que se corresponde con el nodo del grafo.</dd>
<dt><span class="strong">Returns:</span></dt><dd>devuelve un valor de tipo entero que representa el grado del 
 nodo vértice.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="grado_nodo()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grado_nodo</h4>
<pre>public&nbsp;void&nbsp;grado_nodo()
                throws java.lang.Exception</pre>
<div class="block">Método modificador (sobrecargado).
 Muestra por la salida estándar los grados de todos los nodos del grafo
 de trabajo.</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="hallar_puente()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hallar_puente</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="../graphvisualx/Arista.html" title="class in graphvisualx">Arista</a>&gt;&nbsp;hallar_puente()
                                          throws java.lang.Exception</pre>
<div class="block">Algoritmo de comprobación de aristas de corte - Método modificador.
 Muestra por la salida estándar los pares de nodos cuya arista 
 es de corte.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>devolverá un tipo ArrayList<Arista> que contedrá las aristas
 que formarán los puentes del grafo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="vertice_corte()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vertice_corte</h4>
<pre>public&nbsp;boolean&nbsp;vertice_corte()
                      throws java.lang.Exception</pre>
<div class="block">Algoritmo de comprobación de vértices de corte - Método modificador.
 Muestra por la salida estándar los nodos de corte del grafo.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>boolean representa un valor lógico que indica si se ha encontrado
 un punto de corte(true) o no(false) en el grafo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="hallar_corte()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hallar_corte</h4>
<pre>public&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;hallar_corte()
                                                    throws java.lang.Exception</pre>
<div class="block">Algoritmo de comprobación de vértices de corte - Método modificador.
 Muestra por la salida estándar los nodos de corte del grafo.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>ArrayList<Integer> que contendrá los vértices de corte
 del grafo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="orden_topologico()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orden_topologico</h4>
<pre>public&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;orden_topologico()
                                                        throws java.lang.Exception</pre>
<div class="block">Algoritmo de ordenación topológica - Método modificador.
 Muestra por la salida estándar los nodos del grafo siguiente un patrón
 de ordenación topológica.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>resultado que es un ArrayList donde se encuentra el recorrido en
 orden topológico del grafo.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="Bellman_Ford(int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Bellman_Ford</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="../graphvisualx/Arista.html" title="class in graphvisualx">Arista</a>&gt;&nbsp;Bellman_Ford(int&nbsp;origen)
                                         throws java.lang.Exception</pre>
<div class="block">Algoritmo de Bellman-Ford - Método modificador
 Calcula los caminos de coste mínimo entre origen y todos los vértices 
 del grafo G (en este caso origen es 0 y los costes pueden ser negativos).</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>Devuelve una estructura de tipo ArrayList cuyo contenido es de
 tipo Arista. La estructura contendrá los caminos de coste mínimo desde
 un nodo origen para todos los demás nodos.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../graphvisualx/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../graphvisualx/Grafico.html" title="class in graphvisualx"><span class="strong">Prev Class</span></a></li>
<li><a href="../graphvisualx/Graphvisualx.html" title="class in graphvisualx"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?graphvisualx/Grafo.html" target="_top">Frames</a></li>
<li><a href="Grafo.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
