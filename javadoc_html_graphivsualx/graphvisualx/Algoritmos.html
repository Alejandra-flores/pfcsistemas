<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="es">
<head>
<!-- Generated by javadoc (version 1.7.0_147-icedtea) on Tue Feb 14 17:18:31 CET 2012 -->
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
<title>Algoritmos</title>
<meta name="date" content="2012-02-14">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Algoritmos";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../graphvisualx/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../graphvisualx/AbrirFichero.html" title="class in graphvisualx"><span class="strong">Prev Class</span></a></li>
<li><a href="../graphvisualx/Arista.html" title="class in graphvisualx"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?graphvisualx/Algoritmos.html" target="_top">Frames</a></li>
<li><a href="Algoritmos.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">graphvisualx</div>
<h2 title="Class Algoritmos" class="title">Class Algoritmos</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>graphvisualx.Algoritmos</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">Algoritmos</span>
extends java.lang.Object</pre>
<div class="block">Fichero Algoritmos.java</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../graphvisualx/Algoritmos.html#Algoritmos()">Algoritmos</a></strong>()</code>
<div class="block">Constructor nulo.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../graphvisualx/Algoritmos.html#Algoritmos(boolean, boolean)">Algoritmos</a></strong>(boolean&nbsp;adyacente,
          boolean&nbsp;dirigido)</code>
<div class="block">Constructor
 Se establece la variable interna de la clase para la adyacencia
 del mismo.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#AciclicoGD(int[][])">AciclicoGD</a></strong>(int[][]&nbsp;G)</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#AciclicoGND(int[][])">AciclicoGND</a></strong>(int[][]&nbsp;G)</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int[][]</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#algo_Dijkstra(int, int[][])">algo_Dijkstra</a></strong>(int&nbsp;origen,
             int[][]&nbsp;G)</code>
<div class="block">Método observador (Algoritmo de Dijkstra).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int[][]</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#algo_Floyd(int[][], boolean)">algo_Floyd</a></strong>(int[][]&nbsp;G,
          boolean&nbsp;camino)</code>
<div class="block">Método observador (Algoritmo de Floyd).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#algo_Hamilton(int[][], int, int)">algo_Hamilton</a></strong>(int[][]&nbsp;G,
             int&nbsp;v,
             int&nbsp;w)</code>
<div class="block">Método observador (Camino Hamiltoniano)
 Un grafo dirigido tendrá un camino Hamiltoniano 
 (será grafo hamiltoniano) si existe un vértice que partiendo desde él 
 se pase por cada vértice restante del grafo, una sola vez por nodo, y 
 volviendo exactamente al nodo de partida.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.ArrayList</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#algo_Kruskal(int[][], int, int)">algo_Kruskal</a></strong>(int[][]&nbsp;G,
            int&nbsp;n,
            int&nbsp;m)</code>
<div class="block">Método observador (Algoritmo de Kruskal)
 Devuelve en un ArrayList el conjunto de aristas que forman un árbol 
 generador de coste mínimo de un grafo conexo G.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="../graphvisualx/Arista.html" title="class in graphvisualx">Arista</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#algo_Prim(int[][])">algo_Prim</a></strong>(int[][]&nbsp;G)</code>
<div class="block">Método observador (Algoritmo de Prim).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int[][]</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#algo_Warshall(int[][], boolean)">algo_Warshall</a></strong>(int[][]&nbsp;G,
             boolean&nbsp;adyacente)</code>
<div class="block">Método observador (Algoritmo de Warshall).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.ArrayList</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#Bellman_Ford(int[][], int)">Bellman_Ford</a></strong>(int[][]&nbsp;G,
            int&nbsp;x)</code>
<div class="block">Procedimiento de Bellman-Ford (llamada al algoritmo principal)</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#camino_eulerGD(int[][], int, int)">camino_eulerGD</a></strong>(int[][]&nbsp;G,
              int&nbsp;v,
              int&nbsp;w)</code>
<div class="block">Método observador (Euler dirigido)
 Método que llama al procedimiento general para la obtención del camino
 euleriano (si existe) del grafo euleriano (si lo es).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#camino_eulerGND(int[][], int, int)">camino_eulerGND</a></strong>(int[][]&nbsp;G,
               int&nbsp;v,
               int&nbsp;w)</code>
<div class="block">Método observador (Euler no dirigido)
 Método que llama al procedimiento general para la obtención del camino
 euleriano (si existe) del grafo euleriano (si lo es).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#grado_vertice(int, int[][])">grado_vertice</a></strong>(int&nbsp;vertice,
             int[][]&nbsp;G)</code>
<div class="block">Método observador</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#k_colores(int[][])">k_colores</a></strong>(int[][]&nbsp;G)</code>
<div class="block">Método observador (Número cromático del grafo)</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.ArrayList&lt;java.lang.Integer&gt;</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#mostrar_euler()">mostrar_euler</a></strong>()</code>
<div class="block">Método modificador
 Se muestra por el flujo de salida estándar el contenido del camino
 euleriano del grafo (si es que existe).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;java.lang.Integer&gt;</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#ordenacion_topologica(int[][])">ordenacion_topologica</a></strong>(int[][]&nbsp;G)</code>
<div class="block">Método modificador 
 Realiza la ordenación topológica del grafo de trabajo y la muestra
 por el flujo de salida estándar.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="../graphvisualx/Arista.html" title="class in graphvisualx">Arista</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#puentes(int[][])">puentes</a></strong>(int[][]&nbsp;G)</code>
<div class="block">Método modificador
 Método que halla las aristas de corte (puentes) de un grafo.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;java.lang.Integer&gt;</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#recorrido_anchura(int[][])">recorrido_anchura</a></strong>(int[][]&nbsp;G)</code>
<div class="block">Método observador.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.ArrayList&lt;java.lang.Integer&gt;</code></td>
<td class="colLast"><code><strong><a href="../graphvisualx/Algoritmos.html#recorrido_profundidad(int[][])">recorrido_profundidad</a></strong>(int[][]&nbsp;G)</code>
<div class="block">Método observador
 Muestra por la salida estándar el recorrido en profundidad del grafo G.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Algoritmos()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Algoritmos</h4>
<pre>public&nbsp;Algoritmos()</pre>
<div class="block">Constructor nulo.</div>
</li>
</ul>
<a name="Algoritmos(boolean, boolean)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Algoritmos</h4>
<pre>public&nbsp;Algoritmos(boolean&nbsp;adyacente,
          boolean&nbsp;dirigido)</pre>
<div class="block">Constructor
 Se establece la variable interna de la clase para la adyacencia
 del mismo.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>adyacente</code> - parámetro que especifica si el grafo introducido es
 de adyacencia o no.</dd><dd><code>dirigido</code> - parámetro que especifica si el grafo introducido es
 de dirigido o no.</dd></dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="algo_Dijkstra(int, int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>algo_Dijkstra</h4>
<pre>public&nbsp;int[][]&nbsp;algo_Dijkstra(int&nbsp;origen,
                    int[][]&nbsp;G)
                      throws java.lang.Exception</pre>
<div class="block">Método observador (Algoritmo de Dijkstra).
 Calcula los caminos de coste mínimo entre origen y todos los vértices del grafo G.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>origen</code> - vértice desde el que se realiza la computación.</dd><dd><code>G</code> - matriz de costes asociada al grafo G.</dd>
<dt><span class="strong">Returns:</span></dt><dd>Un vector de tamaño G.length con estos costes mínimos (fila 0 de la matriz) y un vector de tamaño G.length tal que vector[i] es el último vértice del camino origen a i (fila 1 de la matriz).</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="algo_Floyd(int[][], boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>algo_Floyd</h4>
<pre>public&nbsp;int[][]&nbsp;algo_Floyd(int[][]&nbsp;G,
                 boolean&nbsp;camino)
                   throws java.lang.Exception</pre>
<div class="block">Método observador (Algoritmo de Floyd).
 Calcula los caminos de coste mínimo entre cada par de vértices del grafo G.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>G</code> - matriz de costes asociada al grafo G.</dd><dd><code>camino</code> - valor booleano que especifica si se quiere mostrar o 
 no el camino asociado a la computación de Floyd.</dd>
<dt><span class="strong">Returns:</span></dt><dd>una matriz(int) de costes mínimos de tamaño NxN.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="algo_Warshall(int[][], boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>algo_Warshall</h4>
<pre>public&nbsp;int[][]&nbsp;algo_Warshall(int[][]&nbsp;G,
                    boolean&nbsp;adyacente)
                      throws java.lang.Exception</pre>
<div class="block">Método observador (Algoritmo de Warshall).
 Determina si hay un camino entre cada par de vértices del grafo G.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>G</code> - matriz de adyacencia asociada al grafo G.</dd>
<dt><span class="strong">Returns:</span></dt><dd>una matriz entera de tamaño NxN, tal que matriz[i][j] == true(1)
 si existe al menos un camino entre el vértice i y el vértice j, 
 y A[i][j] == false(0) si no existe ningún camino entre los 
 vértices i y j.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="algo_Prim(int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>algo_Prim</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="../graphvisualx/Arista.html" title="class in graphvisualx">Arista</a>&gt;&nbsp;algo_Prim(int[][]&nbsp;G)
                                      throws java.lang.Exception</pre>
<div class="block">Método observador (Algoritmo de Prim).
 Devuelve en un vector el conjunto de aristas que forman un árbol
 generador de coste mínimo de un grafo conexo.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>G</code> - matriz de costes asociada al grafo G.</dd>
<dt><span class="strong">Returns:</span></dt><dd>devuelve un ArrayList con el conjunto de aristas que forman 
 un árbol generador de coste mínimo del grafo conexo G.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="algo_Kruskal(int[][], int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>algo_Kruskal</h4>
<pre>public&nbsp;java.util.ArrayList&nbsp;algo_Kruskal(int[][]&nbsp;G,
                               int&nbsp;n,
                               int&nbsp;m)</pre>
<div class="block">Método observador (Algoritmo de Kruskal)
 Devuelve en un ArrayList el conjunto de aristas que forman un árbol 
 generador de coste mínimo de un grafo conexo G.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>G</code> - matriz de costes del grafo conexo G.</dd><dd><code>n</code> - valor entero que representa el número de nodos del grafo.</dd><dd><code>m</code> - valor entero que representa el número de aristas del grafo.</dd>
<dt><span class="strong">Returns:</span></dt><dd>devuelve un ArrayList que será el conjunto de aristas que 
 forman un árbol generador de coste mínimo de un grafo conexo G.</dd></dl>
</li>
</ul>
<a name="Bellman_Ford(int[][], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Bellman_Ford</h4>
<pre>public&nbsp;java.util.ArrayList&nbsp;Bellman_Ford(int[][]&nbsp;G,
                               int&nbsp;x)</pre>
<div class="block">Procedimiento de Bellman-Ford (llamada al algoritmo principal)</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>G</code> - matriz de costes del grafo conexo G.</dd><dd><code>x</code> - valor entero que representa el nodo origen.</dd>
<dt><span class="strong">Returns:</span></dt><dd>devuelve un ArrayList de Arista que representa el procesamiento
 del algoritmo sobre el grafo.</dd></dl>
</li>
</ul>
<a name="recorrido_profundidad(int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recorrido_profundidad</h4>
<pre>public&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;recorrido_profundidad(int[][]&nbsp;G)</pre>
<div class="block">Método observador
 Muestra por la salida estándar el recorrido en profundidad del grafo G.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>G</code> - matriz de adyacencia del grafo conexo.</dd>
<dt><span class="strong">Returns:</span></dt><dd>devuelve un ArrayList de tipo entero que contiene el recorrido
 en profundidad del grafo.</dd></dl>
</li>
</ul>
<a name="recorrido_anchura(int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recorrido_anchura</h4>
<pre>public&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;recorrido_anchura(int[][]&nbsp;G)</pre>
<div class="block">Método observador.
 Muestra por la salida estándar el recorrido en anchura del grafo G.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>G</code> - matriz de adyacencia del grafo conexo.</dd>
<dt><span class="strong">Returns:</span></dt><dd>devuelve un ArrayList de tipo entero que contiene el recorrido
 en anchura del grafo.</dd></dl>
</li>
</ul>
<a name="AciclicoGD(int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>AciclicoGD</h4>
<pre>public&nbsp;boolean&nbsp;AciclicoGD(int[][]&nbsp;G)</pre>
<div class="block">Método observador. (para grafos dirigidos)
 Comprueba si un grafo dirigido es aciclico o no.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>G</code> - array multidimensional (matriz) que contiene la matriz
 de adyacencia del grafo G asociado.</dd>
<dt><span class="strong">Returns:</span></dt><dd>devuelve true o false (verdadero o falso) si se cumple
 que sea o no acíclico.</dd></dl>
</li>
</ul>
<a name="AciclicoGND(int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>AciclicoGND</h4>
<pre>public&nbsp;boolean&nbsp;AciclicoGND(int[][]&nbsp;G)</pre>
<div class="block">Método observador. (para grafos no dirigidos)
 Comprueba si un grafo no dirigido es aciclico o no</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>G</code> - array multidimensional (matriz) que contiene la matriz
 de adyacencia del grafo G asociado.</dd>
<dt><span class="strong">Returns:</span></dt><dd>devuelve true o false (verdadero o falso) si se cumple
 que sea o no acíclico.</dd></dl>
</li>
</ul>
<a name="algo_Hamilton(int[][], int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>algo_Hamilton</h4>
<pre>public&nbsp;void&nbsp;algo_Hamilton(int[][]&nbsp;G,
                 int&nbsp;v,
                 int&nbsp;w)</pre>
<div class="block">Método observador (Camino Hamiltoniano)
 Un grafo dirigido tendrá un camino Hamiltoniano 
 (será grafo hamiltoniano) si existe un vértice que partiendo desde él 
 se pase por cada vértice restante del grafo, una sola vez por nodo, y 
 volviendo exactamente al nodo de partida.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>G</code> - matriz bidimensional de enteros que representa al grafo
 de trabajo.</dd><dd><code>v</code> - valor entero que representa el nodo de partida para el 
 camino.</dd><dd><code>w</code> - valor entero que representa el nodo anterior visitado.</dd></dl>
</li>
</ul>
<a name="k_colores(int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>k_colores</h4>
<pre>public&nbsp;int&nbsp;k_colores(int[][]&nbsp;G)</pre>
<div class="block">Método observador (Número cromático del grafo)</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>G</code> - matriz bidimensional de enteros que representa al grafo de
 trabajo actual.</dd>
<dt><span class="strong">Returns:</span></dt><dd>int que es el número cromático del grafo.</dd></dl>
</li>
</ul>
<a name="puentes(int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>puentes</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="../graphvisualx/Arista.html" title="class in graphvisualx">Arista</a>&gt;&nbsp;puentes(int[][]&nbsp;G)</pre>
<div class="block">Método modificador
 Método que halla las aristas de corte (puentes) de un grafo.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>G</code> - matriz bidimensional de enteros que representa el grafo de
 trabajo actual.</dd>
<dt><span class="strong">Returns:</span></dt><dd>devuelve un tipo ArrayList<Arista> que contendrá las aristas
 que son puentes del grafo.</dd></dl>
</li>
</ul>
<a name="mostrar_euler()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mostrar_euler</h4>
<pre>public&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;mostrar_euler()</pre>
<div class="block">Método modificador
 Se muestra por el flujo de salida estándar el contenido del camino
 euleriano del grafo (si es que existe).</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>Devuelve una estructura ArrayList cuyo contenido es de tipo
 entero donde se encuentra un camino euleriano posible, si es que el 
 grafo posee algún camino.</dd></dl>
</li>
</ul>
<a name="camino_eulerGD(int[][], int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>camino_eulerGD</h4>
<pre>public&nbsp;boolean&nbsp;camino_eulerGD(int[][]&nbsp;G,
                     int&nbsp;v,
                     int&nbsp;w)</pre>
<div class="block">Método observador (Euler dirigido)
 Método que llama al procedimiento general para la obtención del camino
 euleriano (si existe) del grafo euleriano (si lo es).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>G</code> - matriz bidimensional de enteros cuyo contenido es el grafo
 de trabajo actual.</dd><dd><code>v</code> - valor entero que representa el nodo origen para el camino
 euleriano.</dd><dd><code>w</code> - valor entero que representa el nodo anterior procesado 
 (en la primera llamada será el mismo nodo que v).</dd>
<dt><span class="strong">Returns:</span></dt><dd>boolean: devuelve true o fale si hay encontrado o no un 
 camino euleriano para el grafo.</dd></dl>
</li>
</ul>
<a name="camino_eulerGND(int[][], int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>camino_eulerGND</h4>
<pre>public&nbsp;boolean&nbsp;camino_eulerGND(int[][]&nbsp;G,
                      int&nbsp;v,
                      int&nbsp;w)</pre>
<div class="block">Método observador (Euler no dirigido)
 Método que llama al procedimiento general para la obtención del camino
 euleriano (si existe) del grafo euleriano (si lo es).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>G</code> - matriz bidimensional de enteros cuyo contenido es el grafo
 de trabajo actual.</dd><dd><code>v</code> - valor entero que representa el nodo origen para el camino
 euleriano.</dd><dd><code>w</code> - valor entero que representa el nodo anterior procesado 
 (en la primera llamada será el mismo nodo que v).</dd>
<dt><span class="strong">Returns:</span></dt><dd>boolean: devuelve true o fale si hay encontrado o no un 
 camino euleriano para el grafo.</dd></dl>
</li>
</ul>
<a name="grado_vertice(int, int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grado_vertice</h4>
<pre>public&nbsp;int&nbsp;grado_vertice(int&nbsp;vertice,
                int[][]&nbsp;G)</pre>
<div class="block">Método observador</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>vertice</code> - valor de tipo entero que se corresponde con el vértice
 o nodo del grafo.</dd><dd><code>G</code> - matriz de adyacencia o de costes asociada al grafo.</dd>
<dt><span class="strong">Returns:</span></dt><dd>int: valor entero que se corresponde con la valencia del nodo.
 Número de valencia o grado de un vértice son las aristas 
 incidentes en él que contenga.</dd></dl>
</li>
</ul>
<a name="ordenacion_topologica(int[][])">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>ordenacion_topologica</h4>
<pre>public&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;ordenacion_topologica(int[][]&nbsp;G)</pre>
<div class="block">Método modificador 
 Realiza la ordenación topológica del grafo de trabajo y la muestra
 por el flujo de salida estándar.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>G</code> - matriz bidimensional de enteros cuyo contenido es el grafo
 de trabajo actual.</dd>
<dt><span class="strong">Returns:</span></dt><dd>Devuelve una estructura de tipo ArrayList cuyo contenido es 
 entero. En la estructura se encuentra la ordenación topológica del grafo
 procesado.</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../graphvisualx/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../graphvisualx/AbrirFichero.html" title="class in graphvisualx"><span class="strong">Prev Class</span></a></li>
<li><a href="../graphvisualx/Arista.html" title="class in graphvisualx"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?graphvisualx/Algoritmos.html" target="_top">Frames</a></li>
<li><a href="Algoritmos.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
